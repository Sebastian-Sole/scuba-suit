# MVP Plan — Dive Suit Recommender (TanStack Start + MapLibre)

This document is the implementation blueprint for your MVP. It covers **what** to build, **why**, and **how**, with file structure, API contracts, component responsibilities, caching, and acceptance criteria.

---

## 1) Product scope & success criteria

### Core user story

> A diver opens the site, sees a world map with an SST heatmap. They search or click a spot, pick a date, and instantly see a sidebar with historical and predicted surface temperatures plus a wetsuit/drysuit recommendation.

### Must-have features (MVP)

- **Map with SST heatmap overlay** for a chosen date (default = today).
- **Search** for place names and **click-to-select** on the map.
- **Date picker** (past or future). Past → reanalysis; future → forecast.
- **Sidebar** for the selected point showing a **table**:
  - Rows = **historical same-day** temps across N previous years + **upcoming forecast** days.
  - Columns = `date | temperature (°C) | suit recommendation`.

- **Shareable URL** with `lat, lon, date` in query params.

### Acceptance criteria

- Map loads in < 2.5s on broadband; heatmap updates within ~600ms after panning/zooming (debounced).
- Selecting a point yields sidebar data in < 1.5s (warm cache).
- Suit recommendation appears for each row with clear labels and simple rationale.
- Works on desktop and mobile (≥375px wide). Keyboard accessible.

---

## 2) Architecture overview

**Stack**: TanStack Start (full‑stack React + server routes) + MapLibre GL + Tailwind + shadcn/ui.

**Single data source (MVP)**: Open‑Meteo Marine API `sea_surface_temperature` for **global**, **forecast + historical** SST.

**Data flow**

1. **Client** renders MapLibre with a nice ocean basemap.
2. On **map move** / **date change**, client calls `/api/sst/grid?bbox=&date=` → server fetches multi‑coordinate SST for a regular grid inside the viewport and returns points for the heatmap.
3. On **point selection** (click or search result), client calls `/api/sst/point?lat=&lon=&date=` → server fetches hourly SST for:
   - the selected date (avg or nearest hour),
   - forecast window (e.g., next 7 days),
   - historical same-day for the last N years (e.g., 5–10 years),
     and computes **suit recommendations per row**.

4. Sidebar renders a **table** of rows.

**Why this setup?**

- Keeps the MVP **global** and **simple** (one API).
- Server routes handle proxying, caching, and API etiquette (headers, backoff) without exposing keys.

---

## 3) Repo layout (proposal)

```
src/
  routes/
    __root.tsx                # App shell, Tailwind CSS include, layout
    index.tsx                 # Map page
    api/
      sst.grid.ts             # GET: grid sampling → heatmap points
      sst.point.ts            # GET: point & date → table rows + suits
      geocode.ts              # GET: proxy to Nominatim (optional)
  components/
    SSTMap.tsx                # MapLibre map & heatmap layer
    SidebarTable.tsx          # shadcn Table for rows
    SearchBar.tsx             # Input + results
    Legend.tsx                # Heatmap legend & unit toggle (future)
  lib/
    sst.ts                    # Open-Meteo fetchers & transforms
    suit.ts                   # Suit recommendation logic
    cache.ts                  # In-memory LRU wrapper
  styles/app.css              # Tailwind v4 entry
```

Environment variables

```
VITE_MAPTILER_KEY=...         # basemap style tiles (MapTiler or other provider)
NODE_ENV=production
```

---

## 4) Server routes (API design)

### 4.1) `GET /api/sst/grid`

**Query**

- `bbox`: `minLon,minLat,maxLon,maxLat`
- `date`: `YYYY-MM-DD`
- `step` (optional): grid resolution in degrees; default `0.5` (dynamic at zoom).

**Response (200)**

```json
{
  "points": [
    { "lat": 60.39, "lon": 5.32, "temp": 9.7 },
    { "lat": 60.89, "lon": 5.82, "temp": 9.1 }
  ]
}
```

**Notes**

- Server builds a regular grid over the bbox.
- Calls Open‑Meteo with **comma‑separated** lat/lon lists, `hourly=sea_surface_temperature`, `start_date=end_date=date`, `timezone=auto`, and `cell_selection=sea` to bias water cells near coast.
- Averages the returned hourly temps for the day → one value per grid point.
- **Caching**: `Cache-Control: public, max-age=900` + in‑memory LRU (see §7).

### 4.2) `GET /api/sst/point`

**Query**

- `lat`, `lon`: numbers
- `date`: `YYYY-MM-DD`
- `years` (optional): how many back years for historical rows (default `7`).
- `forecastDays` (optional): how many forward days (default `7`).

**Response (200)**

```json
{
  "location": { "lat": 60.392, "lon": 5.324, "display": "Bergen, Norway" },
  "rows": [
    { "date": "2020-11-10", "tempC": 10.3, "suit": {"type":"drysuit", "notes":"< 10–16°C"} },
    { "date": "2021-11-10", "tempC": 9.9,  "suit": {"type":"drysuit"} },
    ...,
    { "date": "2025-11-10", "tempC": 10.1, "suit": {"type":"drysuit"}, "kind":"selected" },
    { "date": "2025-11-11", "tempC": 9.8,  "suit": {"type":"drysuit"}, "kind":"forecast" },
    ...
  ],
  "stats": {
    "mean": 10.0,
    "p10": 8.4,
    "p90": 11.6
  }
}
```

**Notes**

- Server makes **three Open‑Meteo** calls (can be combined/sliced): selected date, historical same‑day (loop `date - 1..N years`), and forward `forecastDays`.
- Computes per‑row suit via `suitForTemp(tempC, prefs)`.
- Includes simple stats for charting (optional).
- **Caching**: 24h for historical rows; 15–60m for forecast/selected date.

### 4.3) `GET /api/geocode`

- Proxies Nominatim with a descriptive `User-Agent` and caches results for 1 day.

---

## 5) Open‑Meteo fetch helpers (`lib/sst.ts`)

Responsibilities

- Build query strings for single or multiple coordinates.
- Parse responses robustly (Open‑Meteo may return `results[]` for multi‑point).
- Timezone handling with `timezone=auto`.
- Land/sea edge cases with `cell_selection=sea` and optional small seaward nudge when value is null.

Pseudo‑code

```ts
export async function fetchSSTDayAvg(
  lat: number,
  lon: number,
  dateISO: string,
): Promise<number | null> {
  const qs = new URLSearchParams({
    latitude: String(lat),
    longitude: String(lon),
    hourly: 'sea_surface_temperature',
    start_date: dateISO,
    end_date: dateISO,
    timezone: 'auto',
    cell_selection: 'sea',
  })
  const r = await fetch(`https://marine-api.open-meteo.com/v1/marine?${qs}`)
  if (!r.ok) throw new Error('Open-Meteo error')
  const j = await r.json()
  const temps: number[] =
    j?.hourly?.sea_surface_temperature ??
    j?.results?.[0]?.hourly?.sea_surface_temperature ??
    []
  if (!temps.length) return null
  return temps.reduce((a, b) => a + b, 0) / temps.length
}
```

---

## 6) Suit recommendation logic (`lib/suit.ts`)

Baseline (scuba‑oriented, conservative; tune later via user prefs):

- **≥ 26 °C** → `shorty-1-3mm`
- **23–26 °C** → `full-3mm`
- **20–23 °C** → `full-5mm` (+hooded vest if long)
- **16–20 °C** → `full-7mm + hood/boots/gloves`
- **10–16 °C** → `drysuit` (or thick semi‑dry)
- **< 10 °C** → `drysuit`

Implementation

```ts
export type Suit = {
  type: 'shorty' | 'full-3mm' | 'full-5mm' | 'full-7mm' | 'drysuit'
  notes?: string
}
export type Prefs = { runsCold?: boolean; diveMinutes?: number }

export function suitForTemp(tempC: number, prefs: Prefs = {}): Suit {
  // simple adjustments
  const bias =
    (prefs.runsCold ? -1 : 0) +
    (prefs.diveMinutes && prefs.diveMinutes > 45 ? -0.5 : 0)
  const t = tempC + bias
  if (t >= 26) return { type: 'shorty', notes: '≥26°C' }
  if (t >= 23) return { type: 'full-3mm', notes: '23–26°C' }
  if (t >= 20) return { type: 'full-5mm', notes: '20–23°C' }
  if (t >= 16) return { type: 'full-7mm', notes: '16–20°C + hood/boots/gloves' }
  if (t >= 10) return { type: 'drysuit', notes: '10–16°C' }
  return { type: 'drysuit', notes: '<10°C' }
}
```

---

## 7) Caching, rate limits & performance

- **In‑memory LRU** cache (e.g., simple Map with TTL) in `/lib/cache.ts` for all server fetches.
  - Grid heatmap points: TTL **15 min**.
  - Point selected date: TTL **15 min**.
  - Historical back years: TTL **24 h**.
  - Geocoding: TTL **24 h**.

- **HTTP caching**: set `Cache-Control` headers on API responses so CDNs (Vercel/Cloudflare) can cache.
- **Debounce** map `moveend` → only refetch after 250–400ms idle.
- **Adaptive grid**: coarser `step` at low zoom (e.g., 1.0°), finer at high zoom (0.25°).
- **Request de‑duplication**: key by `{bbox|lat,lon,date,step}`; coalesce concurrent callers.

---

## 8) Frontend components & UX

### `SSTMap.tsx`

- Props: `points[]`, `dateISO`, `onMoveEnd(bbox)`, `onClick(coord)`.
- Loads **MapLibre** with an **ocean‑focused basemap** (e.g., MapTiler Ocean style).
- Adds a GeoJSON source `sst` + heatmap layer with a sensible color ramp.
- Legend overlay (`Legend.tsx`) explaining color→temp mapping.

### `SearchBar.tsx`

- shadcn Input + Button; submit calls `/api/geocode?q=`; pan map & drop a marker.

### `SidebarTable.tsx`

- Props: `rows[]` from `/api/sst/point`.
- Renders shadcn Table with icons/badges for suit types.
- Sticky section header with selected location, date picker, and a compact sparkline (optional).

### Accessibility

- Keyboard focusable control bar.
- Visible focus rings, sufficient color contrast.
- Table has proper `<th>` and aria labels.

---

## 9) Map & heatmap details

- **Basemap**: MapLibre style URL (MapTiler Ocean or similar). Keep attribution.
- **Heatmap styling**: weight by temperature scaled 0–30°C; set radius≈20–30px.
- **Point selection**: clicking map sends `/api/sst/point`; show a marker and loading state.
- **Null handling**: if a point returns `null`, nudge seaward by 0.02° up to three tries.

---

## 10) Error handling & UX

- Show non‑blocking toast on API errors; retry button.
- Gracefully render `--` for missing data in table.
- If Open‑Meteo rate‑limits/errs, backoff and display a friendly message.

---

## 11) Testing strategy

- **Unit**: `suitForTemp` (edge values, biasing), `sst.ts` parsers for single vs multi‑point.
- **Integration**: mock Open‑Meteo responses for `/api/sst/grid` & `/api/sst/point`.
- **E2E**: Playwright — load map, search Bergen, verify sidebar rows render.

---

## 12) Deployment

- Target: Vercel/Netlify/Cloudflare (any static+serverless works).
- Headers: ensure API routes set appropriate `Cache-Control`.
- Env: `VITE_MAPTILER_KEY` injected at build.

---

## 13) Roadmap (post‑MVP)

- **Depth awareness**: add at‑depth temps (10/20/30 m) from a 3‑D ocean model; render a mini profile and warn on ≥3°C drop.
- **Regional overrides**: if a nearby station exists (NOAA/EMODnet/MET), blend measured temps.
- **User prefs**: sliders for cold/hot and dive duration; remember last location/date.
- **Offline tiles**: prefetch raster tiles for performance.
- **Analytics**: log selected locations and suits (anonymous) to tune thresholds.

---

## 14) Implementation stubs (copy‑paste)

### `/routes/api/sst.grid.ts`

```ts
import { createFileRoute } from '@tanstack/react-router'
import { lru } from '../../lib/cache'

export const Route = createFileRoute('/api/sst/grid')({
  server: {
    handlers: {
      GET: async ({ request }) => {
        const u = new URL(request.url)
        const bbox = u.searchParams.get('bbox')
        const date = u.searchParams.get('date')
        const step = parseFloat(u.searchParams.get('step') ?? '0.5')
        if (!bbox || !date)
          return new Response('Missing bbox/date', { status: 400 })
        const key = `grid:${bbox}:${date}:${step}`
        const cached = lru.get(key)
        if (cached) return jsonOk(cached, 900)

        const nums = bbox.split(',').map(Number)
        const [minLon, minLat, maxLon, maxLat] = nums
        const coords: { lat: number; lon: number }[] = []
        for (let lat = minLat; lat <= maxLat; lat = +(lat + step).toFixed(4))
          for (let lon = minLon; lon <= maxLon; lon = +(lon + step).toFixed(4))
            coords.push({ lat, lon })

        const qs = new URLSearchParams({
          latitude: coords.map((c) => c.lat.toFixed(4)).join(','),
          longitude: coords.map((c) => c.lon.toFixed(4)).join(','),
          hourly: 'sea_surface_temperature',
          start_date: date,
          end_date: date,
          timezone: 'auto',
          cell_selection: 'sea',
        })
        const r = await fetch(
          `https://marine-api.open-meteo.com/v1/marine?${qs}`,
        )
        if (!r.ok) return new Response('Upstream error', { status: 502 })
        const j = await r.json()
        const results = Array.isArray(j) ? j : (j.results ?? [j])
        const points = results.map((res: any, i: number) => {
          const hs = res?.hourly?.sea_surface_temperature ?? []
          const temp = hs.length
            ? hs.reduce((a: number, b: number) => a + b, 0) / hs.length
            : null
          return { ...coords[i], temp }
        })

        const payload = { points }
        lru.set(key, payload, 900)
        return jsonOk(payload, 900)
      },
    },
  },
})

function jsonOk(obj: any, sMaxAge = 0) {
  return new Response(JSON.stringify(obj), {
    headers: {
      'Content-Type': 'application/json',
      'Cache-Control': `public, max-age=${sMaxAge}`,
    },
  })
}
```

### `/routes/api/sst.point.ts`

```ts
import { createFileRoute } from '@tanstack/react-router'
import { lru } from '../../lib/cache'
import { suitForTemp } from '../../lib/suit'
import { fetchSSTDayAvg } from '../../lib/sst'

export const Route = createFileRoute('/api/sst/point')({
  server: {
    handlers: {
      GET: async ({ request }) => {
        const u = new URL(request.url)
        const lat = parseFloat(u.searchParams.get('lat') || '')
        const lon = parseFloat(u.searchParams.get('lon') || '')
        const date = u.searchParams.get('date') || ''
        const years = parseInt(u.searchParams.get('years') || '7')
        const forecastDays = parseInt(u.searchParams.get('forecastDays') || '7')
        if (Number.isNaN(lat) || Number.isNaN(lon) || !date)
          return new Response('Bad params', { status: 400 })

        const key = `pt:${lat.toFixed(3)}:${lon.toFixed(3)}:${date}:${years}:${forecastDays}`
        const cached = lru.get(key)
        if (cached) return jsonOk(cached, 1800)

        // Historical same-day for previous N years
        const year = Number(date.slice(0, 4))
        const monthDay = date.slice(5)
        const histDates = Array.from(
          { length: years },
          (_, i) => `${year - (i + 1)}-${monthDay}`,
        )

        const tempsHist = await Promise.all(
          histDates.map((d) => fetchSSTDayAvg(lat, lon, d)),
        )
        const rowsHist = tempsHist.map((t, i) => ({
          date: histDates[i],
          tempC: t,
          suit: t == null ? null : suitForTemp(t),
        }))

        // Selected date
        const tSel = await fetchSSTDayAvg(lat, lon, date)
        const rowSel = {
          date,
          tempC: tSel,
          suit: tSel == null ? null : suitForTemp(tSel),
          kind: 'selected' as const,
        }

        // Forecast forward (naively: date+1 .. +forecastDays)
        const forwardDates = Array.from({ length: forecastDays }, (_, i) =>
          addDays(date, i + 1),
        )
        const tempsFwd = await Promise.all(
          forwardDates.map((d) => fetchSSTDayAvg(lat, lon, d)),
        )
        const rowsFwd = tempsFwd.map((t, i) => ({
          date: forwardDates[i],
          tempC: t,
          suit: t == null ? null : suitForTemp(t),
          kind: 'forecast' as const,
        }))

        const rows = [...rowsHist.reverse(), rowSel, ...rowsFwd]
        const defined = rows
          .filter((r) => typeof r.tempC === 'number')
          .map((r) => r.tempC as number)
        const stats = defined.length
          ? {
              mean: avg(defined),
              p10: quantile(defined, 0.1),
              p90: quantile(defined, 0.9),
            }
          : null

        const payload = { location: { lat, lon }, rows, stats }
        lru.set(key, payload, 1800)
        return jsonOk(payload, 1800)
      },
    },
  },
})

function jsonOk(obj: any, sMaxAge = 0) {
  return new Response(JSON.stringify(obj), {
    headers: {
      'Content-Type': 'application/json',
      'Cache-Control': `public, max-age=${sMaxAge}`,
    },
  })
}
function addDays(iso: string, n: number) {
  const d = new Date(iso)
  d.setUTCDate(d.getUTCDate() + n)
  return d.toISOString().slice(0, 10)
}
function avg(a: number[]) {
  return a.reduce((x, y) => x + y, 0) / a.length
}
function quantile(a: number[], q: number) {
  const s = [...a].sort((x, y) => x - y)
  const i = Math.floor((s.length - 1) * q)
  return s[i]
}
```

### `lib/cache.ts` (tiny LRU/TTL)

```ts
export const lru = new (class {
  private m = new Map<string, { v: any; exp: number }>()
  get(k: string) {
    const e = this.m.get(k)
    if (!e) return null
    if (Date.now() > e.exp) {
      this.m.delete(k)
      return null
    }
    return e.v
  }
  set(k: string, v: any, ttlSec: number) {
    this.m.set(k, { v, exp: Date.now() + ttlSec * 1000 })
    this.sweep()
  }
  private sweep() {
    if (this.m.size < 200) return
    const now = Date.now()
    for (const [k, e] of this.m) {
      if (now > e.exp) this.m.delete(k)
    }
  }
})()
```

---

## 15) Visual polish checklist

- Basemap: ocean‑focused style; hide POIs/roads at low zoom; keep labels legible.
- Heatmap legend with labeled ticks (e.g., 0, 5, 10, 15, 20, 25, 30°C).
- Suit badges with icons (shorty/3mm/5mm/7mm/drysuit).
- Empty states + skeleton loaders for map & sidebar.

---

**That’s the full blueprint.** Build order suggestion: (1) Tailwind + shadcn wiring, (2) Map + basemap, (3) `/api/sst/grid` + heatmap, (4) `/api/geocode` + search, (5) `/api/sst/point` + sidebar table, (6) polish + tests.
