# Dive Suit Recommender MVP Implementation Plan

## Overview

Building a full-stack dive suit recommender that displays a world map with Sea Surface Temperature (SST) heatmap overlay. Users can click any location or search for a place to see historical temperature data, forecasts, and wetsuit/drysuit recommendations based on Open-Meteo Marine API data.

## Current State Analysis

**Existing Infrastructure:**
- TanStack Start v1.132.0 with full-stack routing configured
- Tailwind v4 with shadcn/ui setup (New York style)
- Environment variable management via @t3-oss/env-core
- TypeScript strict mode enabled
- Path aliases configured (`@/*` → `src/*`)
- No map libraries installed yet
- No UI components created yet (only storybook examples exist)

**What Exists:**
- `src/routes/__root.tsx` - Root layout with Header component
- `src/routes/index.tsx` - Landing page (to be replaced)
- `src/env.ts` - Environment variable schema
- `src/styles.css` - Tailwind configuration with CSS variables
- API route pattern established from demo files

**Key Constraints:**
- Must work globally (not region-specific)
- Single data source: Open-Meteo Marine API (free, no key required)
- Must handle land/sea boundary edge cases
- Mobile-first responsive design (≥375px)
- Performance targets: map load <2.5s, heatmap update <600ms, sidebar data <1.5s

## Desired End State

A production-ready MVP where:
1. Users land on a full-screen interactive map with SST heatmap
2. Map shows current day's temperature overlay by default
3. Users can search for locations by name
4. Clicking any ocean coordinate displays a sidebar with:
   - Historical same-day temperatures (past 7 years)
   - Selected date temperature
   - 7-day forecast
   - Suit recommendations for each date
5. Date picker allows exploring past/future dates
6. URLs are shareable with `?lat=&lon=&date=` parameters
7. All data is cached appropriately for performance
8. Clean, accessible UI with proper loading/error states

### Verification Criteria:

**Automated Verification:**
- [ ] Build completes without errors: `pnpm build`
- [ ] Type checking passes: `pnpm build`
- [ ] Linting passes: `pnpm lint`
- [ ] All dependencies installed correctly: `pnpm install`

**Manual Verification:**
- [ ] Map renders with ocean-focused basemap on load
- [ ] Heatmap appears within 600ms of map movement (after debounce)
- [ ] Search finds "Bergen, Norway" and pans to correct location
- [ ] Clicking ocean coordinate shows sidebar with 15 rows (7 historical + 1 selected + 7 forecast)
- [ ] Each row shows temperature in °C and appropriate suit recommendation
- [ ] Date picker changes heatmap when new date selected
- [ ] URL updates with lat/lon/date parameters
- [ ] Pasting URL with parameters loads correct location and date
- [ ] Null temperature values show gracefully (either nudge seaward or display "-")
- [ ] Mobile layout works at 375px width
- [ ] Keyboard navigation works for map controls and search
- [ ] Loading states appear during data fetches
- [ ] Error states show user-friendly messages

## What We're NOT Doing

- No depth-aware temperature profiles (future: v2)
- No regional data overrides or station blending (future: v2)
- No user preference persistence (future: v2)
- No offline tile caching (future: v2)
- No analytics tracking (future: post-launch)
- No automated testing (unit/integration/E2E)
- No authentication or user accounts
- No custom basemap styling (using free, open basemap)
- No real-time temperature updates (data refreshes on manual interaction)

## Implementation Approach

**Strategy:** Build from the data layer up to the UI layer, implementing backend routes before frontend components that depend on them.

**Phase Order Rationale:**
1. **Infrastructure** - Dependencies, environment, cleanup
2. **Data Layer** - Core SST fetching and caching logic
3. **API Routes** - Server endpoints for grid and point data
4. **Map Foundation** - MapLibre setup with basic controls
5. **Heatmap Integration** - Connect grid API to map visualization
6. **Point Selection** - Click handling and sidebar data
7. **Search & Navigation** - Geocoding and URL state management
8. **Polish** - Loading states, error handling, responsive design

---

## Phase 1: Project Setup & Cleanup

### Overview

Install required dependencies, configure environment variables, and remove demo files to establish clean foundation.

### Changes Required:

#### 1. Install Dependencies

**Command:**
```bash
pnpm add maplibre-gl date-fns
pnpm add -D @types/maplibre-gl
```

**Dependencies:**
- `maplibre-gl` - Open-source map rendering library
- `date-fns` - Date manipulation for forecast calculations
- `@types/maplibre-gl` - TypeScript definitions

#### 2. Update Environment Configuration

**File:** `src/env.ts`

**Changes:** Add optional basemap configuration (future-proof for custom tiles)

```typescript
import { createEnv } from '@t3-oss/env-core'
import { z } from 'zod'

export const env = createEnv({
  server: {
    SERVER_URL: z.string().url().optional(),
    // Future: custom basemap API key if needed
    BASEMAP_API_KEY: z.string().optional(),
  },

  clientPrefix: 'VITE_',

  client: {
    VITE_APP_TITLE: z.string().min(1).optional(),
    // Future: client-side basemap key if needed
    VITE_BASEMAP_API_KEY: z.string().optional(),
  },

  runtimeEnv: import.meta.env,
  emptyStringAsUndefined: true,
})
```

#### 3. Remove Demo Files

**Files to delete:**
- `src/routes/demo/` (entire directory)
- `src/data/demo.punk-songs.ts`
- `src/data/demo-table-data.ts`
- `src/components/storybook/` (entire directory - these are examples)

**Command:**
```bash
rm -rf src/routes/demo src/data/demo*.ts src/components/storybook
```

#### 4. Add MapLibre CSS Import

**File:** `src/styles.css`

**Changes:** Add MapLibre styles at the top

```css
@import 'tailwindcss';
@import 'maplibre-gl/dist/maplibre-gl.css';
@import 'tw-animate-css';

/* ... rest of file stays the same ... */
```

### Success Criteria:

#### Automated Verification:
- [x] Dependencies install successfully: `pnpm install`
- [x] No TypeScript errors: `pnpm build`
- [x] MapLibre CSS loads without 404 errors in dev server

#### Manual Verification:
- [x] Dev server starts without errors: `pnpm dev`
- [x] Demo routes return 404 (confirm cleanup)
- [x] Browser console shows no CSS import errors

---

## Phase 2: Core Data Layer - SST Fetching & Caching

### Overview

Implement reusable utility functions for fetching SST data from Open-Meteo Marine API, with proper error handling, caching, and null-value mitigation strategies.

### Changes Required:

#### 1. Create Cache Utility

**File:** `src/lib/cache.ts` (new file)

**Purpose:** In-memory LRU cache with TTL for all server-side data fetching

```typescript
/**
 * Simple in-memory cache with TTL for server-side data
 * Automatically sweeps expired entries when size exceeds threshold
 */
class SimpleCache {
  private m = new Map<string, { v: any; exp: number }>()

  get(k: string): any | null {
    const e = this.m.get(k)
    if (!e) return null
    if (Date.now() > e.exp) {
      this.m.delete(k)
      return null
    }
    return e.v
  }

  set(k: string, v: any, ttlSec: number): void {
    this.m.set(k, { v, exp: Date.now() + ttlSec * 1000 })
    this.sweep()
  }

  private sweep(): void {
    // Only sweep when cache grows large
    if (this.m.size < 200) return
    const now = Date.now()
    for (const [k, e] of this.m) {
      if (now > e.exp) this.m.delete(k)
    }
  }

  // Expose size for monitoring/debugging
  get size(): number {
    return this.m.size
  }
}

export const cache = new SimpleCache()
```

#### 2. Create SST Fetching Logic

**File:** `src/lib/sst.ts` (new file)

**Purpose:** All Open-Meteo Marine API interactions with proper parsing and error handling

```typescript
/**
 * SST data fetching utilities for Open-Meteo Marine API
 * Handles single and multi-coordinate requests with robust error handling
 */

const MARINE_API_BASE = 'https://marine-api.open-meteo.com/v1/marine'

export interface SSTPoint {
  lat: number
  lon: number
  temp: number | null
}

/**
 * Fetch SST day average for a single coordinate
 * Returns null if no data available (land, ice, or API error)
 */
export async function fetchSSTDayAvg(
  lat: number,
  lon: number,
  dateISO: string,
): Promise<number | null> {
  const qs = new URLSearchParams({
    latitude: lat.toFixed(4),
    longitude: lon.toFixed(4),
    hourly: 'sea_surface_temperature',
    start_date: dateISO,
    end_date: dateISO,
    timezone: 'auto',
    cell_selection: 'sea', // Bias toward ocean cells near coastlines
  })

  try {
    const r = await fetch(`${MARINE_API_BASE}?${qs}`, {
      headers: {
        'User-Agent': 'ScubaSuitRecommender/1.0',
      },
    })

    if (!r.ok) {
      console.warn(`Open-Meteo error for ${lat},${lon} on ${dateISO}: ${r.status}`)
      return null
    }

    const j = await r.json()

    // Open-Meteo returns different structures for single vs multi-point
    const temps: (number | null)[] =
      j?.hourly?.sea_surface_temperature ?? []

    if (!temps.length) return null

    // Filter out null values (ice coverage, land, etc.)
    const validTemps = temps.filter((t): t is number => t !== null)
    if (!validTemps.length) return null

    // Return daily average
    return validTemps.reduce((a, b) => a + b, 0) / validTemps.length
  } catch (err) {
    console.error(`Failed to fetch SST for ${lat},${lon}:`, err)
    return null
  }
}

/**
 * Fetch SST for multiple coordinates (grid sampling)
 * More efficient than individual requests for heatmap data
 */
export async function fetchSSTGrid(
  coords: Array<{ lat: number; lon: number }>,
  dateISO: string,
): Promise<SSTPoint[]> {
  if (!coords.length) return []

  const qs = new URLSearchParams({
    latitude: coords.map((c) => c.lat.toFixed(4)).join(','),
    longitude: coords.map((c) => c.lon.toFixed(4)).join(','),
    hourly: 'sea_surface_temperature',
    start_date: dateISO,
    end_date: dateISO,
    timezone: 'auto',
    cell_selection: 'sea',
  })

  try {
    const r = await fetch(`${MARINE_API_BASE}?${qs}`, {
      headers: {
        'User-Agent': 'ScubaSuitRecommender/1.0',
      },
    })

    if (!r.ok) {
      console.warn(`Open-Meteo grid error: ${r.status}`)
      return coords.map((c) => ({ ...c, temp: null }))
    }

    const j = await r.json()

    // Multi-coordinate responses are in j.results array
    const results = j.results ?? [j]

    return results.map((res: any, i: number) => {
      const temps: (number | null)[] =
        res?.hourly?.sea_surface_temperature ?? []

      const validTemps = temps.filter((t): t is number => t !== null)
      const temp =
        validTemps.length > 0
          ? validTemps.reduce((a, b) => a + b, 0) / validTemps.length
          : null

      return {
        lat: coords[i].lat,
        lon: coords[i].lon,
        temp,
      }
    })
  } catch (err) {
    console.error('Failed to fetch SST grid:', err)
    return coords.map((c) => ({ ...c, temp: null }))
  }
}

/**
 * Attempt to find valid SST by nudging coordinate seaward
 * Useful for coastal/land-edge clicks that return null
 */
export async function fetchSSTWithNudge(
  lat: number,
  lon: number,
  dateISO: string,
  maxAttempts = 3,
): Promise<number | null> {
  let temp = await fetchSSTDayAvg(lat, lon, dateISO)
  if (temp !== null) return temp

  // Try nudging slightly in different directions (simplified: just east/west)
  const nudgeAmount = 0.02 // ~2km at equator
  const attempts = [
    { lat, lon: lon + nudgeAmount },
    { lat, lon: lon - nudgeAmount },
    { lat: lat + nudgeAmount, lon },
  ]

  for (let i = 0; i < Math.min(maxAttempts, attempts.length); i++) {
    temp = await fetchSSTDayAvg(
      attempts[i].lat,
      attempts[i].lon,
      dateISO,
    )
    if (temp !== null) return temp
  }

  return null
}
```

#### 3. Create Suit Recommendation Logic

**File:** `src/lib/suit.ts` (new file)

**Purpose:** Temperature-to-wetsuit mapping with clear thresholds

```typescript
/**
 * Dive suit recommendation logic based on surface temperature
 * Thresholds are scuba-oriented and conservative
 */

export type SuitType =
  | 'shorty'
  | 'full-3mm'
  | 'full-5mm'
  | 'full-7mm'
  | 'drysuit'

export interface Suit {
  type: SuitType
  notes?: string
}

export interface UserPrefs {
  runsCold?: boolean
  diveMinutes?: number
}

/**
 * Returns suit recommendation for given temperature
 * Applies optional user preference adjustments
 */
export function suitForTemp(tempC: number, prefs: UserPrefs = {}): Suit {
  // Apply preference-based bias
  const bias =
    (prefs.runsCold ? -1 : 0) +
    (prefs.diveMinutes && prefs.diveMinutes > 45 ? -0.5 : 0)

  const adjustedTemp = tempC + bias

  if (adjustedTemp >= 26) {
    return { type: 'shorty', notes: '≥26°C - warm tropical waters' }
  }

  if (adjustedTemp >= 23) {
    return { type: 'full-3mm', notes: '23–26°C - warm waters' }
  }

  if (adjustedTemp >= 20) {
    return {
      type: 'full-5mm',
      notes: '20–23°C - temperate waters',
    }
  }

  if (adjustedTemp >= 16) {
    return {
      type: 'full-7mm',
      notes: '16–20°C - cold waters, add hood/gloves',
    }
  }

  if (adjustedTemp >= 10) {
    return {
      type: 'drysuit',
      notes: '10–16°C - cold waters, drysuit recommended',
    }
  }

  return {
    type: 'drysuit',
    notes: '<10°C - very cold waters, drysuit required',
  }
}

/**
 * Human-readable suit type labels
 */
export const SUIT_LABELS: Record<SuitType, string> = {
  shorty: 'Shorty (1-3mm)',
  'full-3mm': 'Full Wetsuit (3mm)',
  'full-5mm': 'Full Wetsuit (5mm)',
  'full-7mm': 'Full Wetsuit (7mm)',
  drysuit: 'Drysuit',
}
```

#### 4. Create Date Utilities

**File:** `src/lib/dates.ts` (new file)

**Purpose:** Date manipulation helpers for forecast/historical calculations

```typescript
/**
 * Date utility functions for SST data fetching
 */

/**
 * Add days to ISO date string (YYYY-MM-DD)
 */
export function addDays(dateISO: string, days: number): string {
  const d = new Date(dateISO + 'T00:00:00Z')
  d.setUTCDate(d.getUTCDate() + days)
  return d.toISOString().slice(0, 10)
}

/**
 * Get today's date in ISO format
 */
export function getTodayISO(): string {
  return new Date().toISOString().slice(0, 10)
}

/**
 * Generate array of historical same-day dates for previous N years
 */
export function getHistoricalDates(dateISO: string, years: number): string[] {
  const year = Number(dateISO.slice(0, 4))
  const monthDay = dateISO.slice(5) // MM-DD

  return Array.from({ length: years }, (_, i) => {
    const historicalYear = year - (i + 1)
    return `${historicalYear}-${monthDay}`
  })
}

/**
 * Generate array of future dates for forecast
 */
export function getForecastDates(dateISO: string, days: number): string[] {
  return Array.from({ length: days }, (_, i) => addDays(dateISO, i + 1))
}

/**
 * Validate ISO date format (basic check)
 */
export function isValidISODate(dateISO: string): boolean {
  return /^\d{4}-\d{2}-\d{2}$/.test(dateISO) && !isNaN(Date.parse(dateISO))
}
```

### Success Criteria:

#### Automated Verification:
- [x] TypeScript compilation succeeds: `pnpm build`
- [x] No linting errors in new files: `pnpm lint`

#### Manual Verification:
- [x] Can import and call `fetchSSTDayAvg(60.39, 5.32, '2025-11-10')` in test route and get valid data
- [x] Cache stores and retrieves values correctly
- [x] `suitForTemp(15)` returns `{ type: 'drysuit', notes: ... }`
- [x] Date utilities produce correct date arrays

---

## Phase 3: API Routes - Grid & Point Endpoints

### Overview

Implement server-side API routes for fetching heatmap grid data and point-specific historical/forecast data with appropriate caching.

### Changes Required:

#### 1. Grid API Route (Heatmap Data)

**File:** `src/routes/api/sst/grid.ts` (new file)

**Purpose:** Returns SST data for a regular grid within viewport bounds

```typescript
import { createFileRoute, json } from '@tanstack/react-start'
import { z } from 'zod'
import { cache } from '@/lib/cache'
import { fetchSSTGrid } from '@/lib/sst'

// Input validation schema
const gridQuerySchema = z.object({
  bbox: z.string().regex(/^-?\d+\.?\d*,-?\d+\.?\d*,-?\d+\.?\d*,-?\d+\.?\d*$/),
  date: z.string().regex(/^\d{4}-\d{2}-\d{2}$/),
  step: z.string().optional().default('0.5'),
})

export const Route = createFileRoute('/api/sst/grid')({
  server: {
    handlers: {
      GET: async ({ request }) => {
        const url = new URL(request.url)
        const params = Object.fromEntries(url.searchParams)

        // Validate input
        const parseResult = gridQuerySchema.safeParse(params)
        if (!parseResult.success) {
          return json(
            { error: 'Invalid parameters', details: parseResult.error.issues },
            { status: 400 },
          )
        }

        const { bbox, date, step } = parseResult.data
        const stepNum = parseFloat(step)

        // Check cache first
        const cacheKey = `grid:${bbox}:${date}:${stepNum}`
        const cached = cache.get(cacheKey)
        if (cached) {
          return json(cached, {
            headers: {
              'Cache-Control': 'public, max-age=900', // 15 min
            },
          })
        }

        // Parse bounding box
        const [minLon, minLat, maxLon, maxLat] = bbox.split(',').map(Number)

        // Generate regular grid of coordinates
        const coords: Array<{ lat: number; lon: number }> = []
        for (
          let lat = minLat;
          lat <= maxLat;
          lat = Math.round((lat + stepNum) * 10000) / 10000
        ) {
          for (
            let lon = minLon;
            lon <= maxLon;
            lon = Math.round((lon + stepNum) * 10000) / 10000
          ) {
            coords.push({ lat, lon })
          }
        }

        // Limit grid size to prevent excessive API calls
        if (coords.length > 1000) {
          return json(
            {
              error: 'Grid too large',
              message: 'Reduce zoom level or increase step size',
            },
            { status: 400 },
          )
        }

        // Fetch SST data for grid
        try {
          const points = await fetchSSTGrid(coords, date)
          const payload = { points }

          // Cache for 15 minutes
          cache.set(cacheKey, payload, 900)

          return json(payload, {
            headers: {
              'Cache-Control': 'public, max-age=900',
            },
          })
        } catch (err) {
          console.error('Grid fetch error:', err)
          return json(
            { error: 'Failed to fetch SST data' },
            { status: 502 },
          )
        }
      },
    },
  },
})
```

#### 2. Point API Route (Sidebar Data)

**File:** `src/routes/api/sst/point.ts` (new file)

**Purpose:** Returns historical, current, and forecast SST with suit recommendations

```typescript
import { createFileRoute, json } from '@tanstack/react-start'
import { z } from 'zod'
import { cache } from '@/lib/cache'
import { fetchSSTDayAvg, fetchSSTWithNudge } from '@/lib/sst'
import { suitForTemp } from '@/lib/suit'
import {
  getHistoricalDates,
  getForecastDates,
  isValidISODate,
} from '@/lib/dates'

// Input validation schema
const pointQuerySchema = z.object({
  lat: z.string().regex(/^-?\d+\.?\d*$/),
  lon: z.string().regex(/^-?\d+\.?\d*$/),
  date: z.string().regex(/^\d{4}-\d{2}-\d{2}$/),
  years: z.string().optional().default('7'),
  forecastDays: z.string().optional().default('7'),
})

export const Route = createFileRoute('/api/sst/point')({
  server: {
    handlers: {
      GET: async ({ request }) => {
        const url = new URL(request.url)
        const params = Object.fromEntries(url.searchParams)

        // Validate input
        const parseResult = pointQuerySchema.safeParse(params)
        if (!parseResult.success) {
          return json(
            { error: 'Invalid parameters', details: parseResult.error.issues },
            { status: 400 },
          )
        }

        const { lat: latStr, lon: lonStr, date, years: yearsStr, forecastDays: forecastDaysStr } = parseResult.data
        const lat = parseFloat(latStr)
        const lon = parseFloat(lonStr)
        const years = parseInt(yearsStr)
        const forecastDays = parseInt(forecastDaysStr)

        if (!isValidISODate(date)) {
          return json({ error: 'Invalid date format' }, { status: 400 })
        }

        // Check cache (shorter TTL for selected/forecast dates)
        const cacheKey = `point:${lat.toFixed(3)}:${lon.toFixed(3)}:${date}:${years}:${forecastDays}`
        const cached = cache.get(cacheKey)
        if (cached) {
          return json(cached, {
            headers: {
              'Cache-Control': 'public, max-age=1800', // 30 min
            },
          })
        }

        try {
          // Fetch historical same-day temperatures
          const historicalDates = getHistoricalDates(date, years)
          const historicalTemps = await Promise.all(
            historicalDates.map((d) => fetchSSTDayAvg(lat, lon, d)),
          )

          const historicalRows = historicalDates.map((d, i) => ({
            date: d,
            tempC: historicalTemps[i],
            suit: historicalTemps[i] !== null ? suitForTemp(historicalTemps[i]) : null,
            kind: 'historical' as const,
          }))

          // Fetch selected date temperature (with nudge if null)
          const selectedTemp = await fetchSSTWithNudge(lat, lon, date, 3)
          const selectedRow = {
            date,
            tempC: selectedTemp,
            suit: selectedTemp !== null ? suitForTemp(selectedTemp) : null,
            kind: 'selected' as const,
          }

          // Fetch forecast temperatures
          const forecastDates = getForecastDates(date, forecastDays)
          const forecastTemps = await Promise.all(
            forecastDates.map((d) => fetchSSTDayAvg(lat, lon, d)),
          )

          const forecastRows = forecastDates.map((d, i) => ({
            date: d,
            tempC: forecastTemps[i],
            suit: forecastTemps[i] !== null ? suitForTemp(forecastTemps[i]) : null,
            kind: 'forecast' as const,
          }))

          // Combine all rows (historical → selected → forecast)
          const rows = [
            ...historicalRows.reverse(), // Oldest to newest
            selectedRow,
            ...forecastRows,
          ]

          // Calculate statistics from valid temperatures
          const validTemps = rows
            .filter((r) => r.tempC !== null)
            .map((r) => r.tempC as number)

          const stats = validTemps.length
            ? {
                mean: validTemps.reduce((a, b) => a + b, 0) / validTemps.length,
                min: Math.min(...validTemps),
                max: Math.max(...validTemps),
                p10: quantile(validTemps, 0.1),
                p90: quantile(validTemps, 0.9),
              }
            : null

          const payload = {
            location: { lat, lon },
            rows,
            stats,
          }

          // Cache for 30 minutes
          cache.set(cacheKey, payload, 1800)

          return json(payload, {
            headers: {
              'Cache-Control': 'public, max-age=1800',
            },
          })
        } catch (err) {
          console.error('Point fetch error:', err)
          return json(
            { error: 'Failed to fetch SST data' },
            { status: 502 },
          )
        }
      },
    },
  },
})

// Helper for percentile calculation
function quantile(arr: number[], q: number): number {
  const sorted = [...arr].sort((a, b) => a - b)
  const pos = (sorted.length - 1) * q
  const base = Math.floor(pos)
  const rest = pos - base
  if (sorted[base + 1] !== undefined) {
    return sorted[base] + rest * (sorted[base + 1] - sorted[base])
  }
  return sorted[base]
}
```

#### 3. Geocoding API Route

**File:** `src/routes/api/geocode.ts` (new file)

**Purpose:** Proxy to Nominatim for location search with caching

```typescript
import { createFileRoute, json } from '@tanstack/react-start'
import { z } from 'zod'
import { cache } from '@/lib/cache'

const geocodeQuerySchema = z.object({
  q: z.string().min(1),
})

export const Route = createFileRoute('/api/geocode')({
  server: {
    handlers: {
      GET: async ({ request }) => {
        const url = new URL(request.url)
        const params = Object.fromEntries(url.searchParams)

        // Validate input
        const parseResult = geocodeQuerySchema.safeParse(params)
        if (!parseResult.success) {
          return json(
            { error: 'Missing query parameter' },
            { status: 400 },
          )
        }

        const { q } = parseResult.data

        // Check cache (24h for geocoding results)
        const cacheKey = `geocode:${q.toLowerCase()}`
        const cached = cache.get(cacheKey)
        if (cached) {
          return json(cached, {
            headers: {
              'Cache-Control': 'public, max-age=86400', // 24 hours
            },
          })
        }

        try {
          // Use Nominatim (free, open geocoder)
          const nominatimUrl = new URL('https://nominatim.openstreetmap.org/search')
          nominatimUrl.searchParams.set('q', q)
          nominatimUrl.searchParams.set('format', 'json')
          nominatimUrl.searchParams.set('limit', '5')

          const response = await fetch(nominatimUrl.toString(), {
            headers: {
              'User-Agent': 'ScubaSuitRecommender/1.0 (contact@example.com)',
            },
          })

          if (!response.ok) {
            return json(
              { error: 'Geocoding service unavailable' },
              { status: 502 },
            )
          }

          const results = await response.json()

          // Transform to our format
          const locations = results.map((r: any) => ({
            lat: parseFloat(r.lat),
            lon: parseFloat(r.lon),
            display: r.display_name,
          }))

          const payload = { locations }

          // Cache for 24 hours
          cache.set(cacheKey, payload, 86400)

          return json(payload, {
            headers: {
              'Cache-Control': 'public, max-age=86400',
            },
          })
        } catch (err) {
          console.error('Geocoding error:', err)
          return json(
            { error: 'Failed to geocode location' },
            { status: 502 },
          )
        }
      },
    },
  },
})
```

### Success Criteria:

#### Automated Verification:
- [x] Build succeeds with new routes: `pnpm build`
- [x] No TypeScript errors: `pnpm build`

#### Manual Verification:
- [x] `curl "http://localhost:3000/api/sst/grid?bbox=5,60,6,61&date=2025-11-10&step=0.5"` returns grid points
- [x] `curl "http://localhost:3000/api/sst/point?lat=60.39&lon=5.32&date=2025-11-10"` returns rows with temps and suits
- [x] `curl "http://localhost:3000/api/geocode?q=Bergen"` returns location results
- [x] Invalid parameters return 400 errors with helpful messages
- [x] Cache headers are present in responses
- [x] Subsequent identical requests are faster (cache hit)

---

## Phase 4: Map Foundation - MapLibre Setup

### Overview

Create the base map component with MapLibre, ocean-focused basemap, and basic controls. This establishes the visual foundation before adding interactive layers.

### Changes Required:

#### 1. Create Map Component

**File:** `src/components/SSTMap.tsx` (new file)

**Purpose:** MapLibre wrapper with ocean basemap and event handling

```typescript
'use client'

import { useEffect, useRef, useState } from 'react'
import maplibregl, { Map as MapLibreMap } from 'maplibre-gl'

export interface MapPoint {
  lat: number
  lon: number
  temp: number | null
}

export interface SSTMapProps {
  points: MapPoint[]
  selectedDate: string
  onMapMove?: (bounds: {
    minLon: number
    minLat: number
    maxLon: number
    maxLat: number
  }) => void
  onMapClick?: (lat: number, lon: number) => void
  initialCenter?: [number, number] // [lon, lat]
  initialZoom?: number
}

export function SSTMap({
  points,
  selectedDate,
  onMapMove,
  onMapClick,
  initialCenter = [5, 55], // North Sea default
  initialZoom = 4,
}: SSTMapProps) {
  const mapContainer = useRef<HTMLDivElement>(null)
  const map = useRef<MapLibreMap | null>(null)
  const [isMapLoaded, setIsMapLoaded] = useState(false)

  // Initialize map
  useEffect(() => {
    if (!mapContainer.current || map.current) return

    // Use OpenStreetMap as free basemap
    // Future: can swap to custom MapTiler style with API key
    map.current = new maplibregl.Map({
      container: mapContainer.current,
      style: {
        version: 8,
        sources: {
          'osm-tiles': {
            type: 'raster',
            tiles: [
              'https://a.tile.openstreetmap.org/{z}/{x}/{y}.png',
              'https://b.tile.openstreetmap.org/{z}/{x}/{y}.png',
              'https://c.tile.openstreetmap.org/{z}/{x}/{y}.png',
            ],
            tileSize: 256,
            attribution:
              '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
          },
        },
        layers: [
          {
            id: 'osm-tiles',
            type: 'raster',
            source: 'osm-tiles',
            minzoom: 0,
            maxzoom: 19,
          },
        ],
      },
      center: initialCenter,
      zoom: initialZoom,
    })

    // Add navigation controls
    map.current.addControl(new maplibregl.NavigationControl(), 'top-right')

    // Mark map as loaded
    map.current.on('load', () => {
      setIsMapLoaded(true)
    })

    // Cleanup
    return () => {
      map.current?.remove()
      map.current = null
    }
  }, [initialCenter, initialZoom])

  // Handle map movement (debounced in parent)
  useEffect(() => {
    if (!map.current || !onMapMove) return

    const handleMoveEnd = () => {
      if (!map.current) return
      const bounds = map.current.getBounds()
      onMapMove({
        minLon: bounds.getWest(),
        minLat: bounds.getSouth(),
        maxLon: bounds.getEast(),
        maxLat: bounds.getNorth(),
      })
    }

    map.current.on('moveend', handleMoveEnd)

    return () => {
      map.current?.off('moveend', handleMoveEnd)
    }
  }, [onMapMove])

  // Handle map clicks
  useEffect(() => {
    if (!map.current || !onMapClick) return

    const handleClick = (e: maplibregl.MapMouseEvent) => {
      onMapClick(e.lngLat.lat, e.lngLat.lng)
    }

    map.current.on('click', handleClick)

    return () => {
      map.current?.off('click', handleClick)
    }
  }, [onMapClick])

  return (
    <div className="relative w-full h-full">
      <div ref={mapContainer} className="absolute inset-0" />
      {!isMapLoaded && (
        <div className="absolute inset-0 flex items-center justify-center bg-slate-900/50">
          <div className="text-white">Loading map...</div>
        </div>
      )}
    </div>
  )
}
```

#### 2. Update Root Route Title

**File:** `src/routes/__root.tsx`

**Changes:** Update meta title for the app

```typescript
// ... existing imports ...

export const Route = createRootRoute({
  head: () => ({
    meta: [
      {
        charSet: 'utf-8',
      },
      {
        name: 'viewport',
        content: 'width=device-width, initial-scale=1',
      },
      {
        title: 'Dive Suit Recommender - Find the Right Wetsuit',
      },
      {
        name: 'description',
        content: 'Get wetsuit and drysuit recommendations based on real ocean temperatures worldwide.',
      },
    ],
    links: [
      {
        rel: 'stylesheet',
        href: appCss,
      },
    ],
  }),

  shellComponent: RootDocument,
})

// ... rest stays the same ...
```

#### 3. Create Basic Map Page

**File:** `src/routes/index.tsx`

**Changes:** Replace landing page with map view

```typescript
import { createFileRoute } from '@tanstack/react-router'
import { useState } from 'react'
import { SSTMap } from '@/components/SSTMap'
import { getTodayISO } from '@/lib/dates'

export const Route = createFileRoute('/')({
  component: MapPage,
})

function MapPage() {
  const [selectedDate] = useState(getTodayISO())
  const [points] = useState([]) // Will be populated in next phase

  return (
    <div className="h-screen w-full flex flex-col">
      {/* Map container */}
      <div className="flex-1 relative">
        <SSTMap
          points={points}
          selectedDate={selectedDate}
          onMapMove={(bounds) => {
            console.log('Map moved:', bounds)
          }}
          onMapClick={(lat, lon) => {
            console.log('Map clicked:', lat, lon)
          }}
        />
      </div>
    </div>
  )
}
```

### Success Criteria:

#### Automated Verification:
- [x] Build succeeds: `pnpm build`
- [x] No TypeScript errors

#### Manual Verification:
- [x] Map renders on homepage with OSM tiles
- [x] Navigation controls (zoom, pan) work
- [x] Console logs show bounds when map is moved
- [x] Console logs show coordinates when map is clicked
- [x] Map is full-screen and responsive
- [x] No 404 errors for tiles in network tab

---

## Phase 5: Heatmap Integration - Grid Data Visualization

### Overview

Connect the grid API to the map component and render SST data as a heatmap layer. Implement debounced fetching and dynamic grid resolution based on zoom level.

### Changes Required:

#### 1. Add Heatmap Layer to Map Component

**File:** `src/components/SSTMap.tsx`

**Changes:** Add GeoJSON source and heatmap layer when data updates

```typescript
// ... existing imports ...

export function SSTMap({
  points,
  selectedDate,
  onMapMove,
  onMapClick,
  initialCenter = [5, 55],
  initialZoom = 4,
}: SSTMapProps) {
  // ... existing state and refs ...

  // Update heatmap data when points change
  useEffect(() => {
    if (!map.current || !isMapLoaded || !points.length) return

    const geojsonData = {
      type: 'FeatureCollection' as const,
      features: points
        .filter((p) => p.temp !== null)
        .map((p) => ({
          type: 'Feature' as const,
          geometry: {
            type: 'Point' as const,
            coordinates: [p.lon, p.lat],
          },
          properties: {
            temperature: p.temp,
          },
        })),
    }

    // Add source if it doesn't exist
    if (!map.current.getSource('sst-data')) {
      map.current.addSource('sst-data', {
        type: 'geojson',
        data: geojsonData,
      })

      // Add heatmap layer
      map.current.addLayer({
        id: 'sst-heatmap',
        type: 'heatmap',
        source: 'sst-data',
        paint: {
          // Color ramp: blue (cold) → yellow (warm) → red (hot)
          'heatmap-color': [
            'interpolate',
            ['linear'],
            ['heatmap-density'],
            0, 'rgba(0, 0, 255, 0)',
            0.2, 'rgb(0, 100, 255)',
            0.4, 'rgb(0, 200, 255)',
            0.6, 'rgb(0, 255, 200)',
            0.8, 'rgb(255, 255, 0)',
            1, 'rgb(255, 100, 0)',
          ],
          // Weight by temperature (normalized to 0-30°C range)
          'heatmap-weight': [
            'interpolate',
            ['linear'],
            ['get', 'temperature'],
            0, 0,
            30, 1,
          ],
          // Increase intensity as zoom increases
          'heatmap-intensity': [
            'interpolate',
            ['linear'],
            ['zoom'],
            0, 1,
            9, 3,
          ],
          // Radius of influence
          'heatmap-radius': [
            'interpolate',
            ['linear'],
            ['zoom'],
            0, 20,
            9, 40,
          ],
          // Fade out at high zoom
          'heatmap-opacity': [
            'interpolate',
            ['linear'],
            ['zoom'],
            7, 0.8,
            9, 0.6,
          ],
        },
      })
    } else {
      // Update existing source
      const source = map.current.getSource('sst-data')
      if (source && source.type === 'geojson') {
        source.setData(geojsonData)
      }
    }
  }, [points, isMapLoaded])

  // ... rest of component stays the same ...
}
```

#### 2. Create Heatmap Legend Component

**File:** `src/components/Legend.tsx` (new file)

**Purpose:** Visual reference for temperature-to-color mapping

```typescript
export function Legend() {
  const colorStops = [
    { temp: 0, color: 'rgb(0, 100, 255)', label: '0°C' },
    { temp: 10, color: 'rgb(0, 200, 255)', label: '10°C' },
    { temp: 15, color: 'rgb(0, 255, 200)', label: '15°C' },
    { temp: 20, color: 'rgb(255, 255, 0)', label: '20°C' },
    { temp: 25, color: 'rgb(255, 150, 0)', label: '25°C' },
    { temp: 30, color: 'rgb(255, 100, 0)', label: '30°C' },
  ]

  return (
    <div className="absolute bottom-8 left-4 bg-white/90 backdrop-blur-sm rounded-lg p-4 shadow-lg">
      <h3 className="text-sm font-semibold mb-2 text-slate-900">
        Sea Surface Temperature
      </h3>
      <div className="flex flex-col gap-1">
        {colorStops.map((stop) => (
          <div key={stop.temp} className="flex items-center gap-2">
            <div
              className="w-6 h-3 rounded"
              style={{ backgroundColor: stop.color }}
            />
            <span className="text-xs text-slate-700">{stop.label}</span>
          </div>
        ))}
      </div>
    </div>
  )
}
```

#### 3. Implement Debounced Grid Fetching

**File:** `src/routes/index.tsx`

**Changes:** Add grid data fetching with debounce and zoom-based step calculation

```typescript
import { createFileRoute } from '@tanstack/react-router'
import { useState, useCallback, useEffect, useRef } from 'react'
import { SSTMap, MapPoint } from '@/components/SSTMap'
import { Legend } from '@/components/Legend'
import { getTodayISO } from '@/lib/dates'

export const Route = createFileRoute('/')({
  component: MapPage,
})

function MapPage() {
  const [selectedDate] = useState(getTodayISO())
  const [points, setPoints] = useState<MapPoint[]>([])
  const [isLoadingGrid, setIsLoadingGrid] = useState(false)
  const debounceTimer = useRef<NodeJS.Timeout | null>(null)

  // Fetch grid data with debounce
  const fetchGridData = useCallback(
    async (bounds: {
      minLon: number
      minLat: number
      maxLon: number
      maxLat: number
    }) => {
      setIsLoadingGrid(true)

      // Calculate adaptive step based on viewport size
      // Smaller viewport = finer grid
      const latRange = bounds.maxLat - bounds.minLat
      const lonRange = bounds.maxLon - bounds.minLon
      const area = latRange * lonRange
      const step = area > 200 ? 1.0 : area > 50 ? 0.5 : 0.25

      const bbox = `${bounds.minLon},${bounds.minLat},${bounds.maxLon},${bounds.maxLat}`
      const url = `/api/sst/grid?bbox=${bbox}&date=${selectedDate}&step=${step}`

      try {
        const response = await fetch(url)
        if (!response.ok) throw new Error('Failed to fetch grid data')

        const data = await response.json()
        setPoints(data.points)
      } catch (err) {
        console.error('Error fetching grid data:', err)
        // Show error toast in future
      } finally {
        setIsLoadingGrid(false)
      }
    },
    [selectedDate],
  )

  // Debounced map move handler
  const handleMapMove = useCallback(
    (bounds: {
      minLon: number
      minLat: number
      maxLon: number
      maxLat: number
    }) => {
      // Clear existing timer
      if (debounceTimer.current) {
        clearTimeout(debounceTimer.current)
      }

      // Set new timer
      debounceTimer.current = setTimeout(() => {
        fetchGridData(bounds)
      }, 400) // 400ms debounce
    },
    [fetchGridData],
  )

  // Cleanup timer on unmount
  useEffect(() => {
    return () => {
      if (debounceTimer.current) {
        clearTimeout(debounceTimer.current)
      }
    }
  }, [])

  return (
    <div className="h-screen w-full flex flex-col">
      <div className="flex-1 relative">
        <SSTMap
          points={points}
          selectedDate={selectedDate}
          onMapMove={handleMapMove}
          onMapClick={(lat, lon) => {
            console.log('Clicked:', lat, lon)
          }}
        />
        <Legend />
        {isLoadingGrid && (
          <div className="absolute top-4 right-4 bg-slate-900/80 text-white px-4 py-2 rounded-lg text-sm">
            Loading temperature data...
          </div>
        )}
      </div>
    </div>
  )
}
```

### Success Criteria:

#### Automated Verification:
- [x] Build succeeds: `pnpm build`
- [x] No TypeScript errors

#### Manual Verification:
- [x] Heatmap appears on initial map load
- [x] Heatmap updates when panning/zooming (after ~400ms debounce)
- [x] Loading indicator appears during data fetch
- [x] Legend shows temperature-to-color mapping
- [x] Heatmap colors roughly match legend (blue=cold, red=hot)
- [x] Grid adapts density based on zoom level
- [x] Network tab shows grid API calls with appropriate caching

---

## Phase 6: Point Selection & Sidebar - Historical/Forecast Data

### Overview

Implement click handling to fetch detailed point data and display it in a sidebar table with suit recommendations.

### Changes Required:

#### 1. Create Sidebar Table Component

**File:** `src/components/SidebarTable.tsx` (new file)

**Purpose:** Display temperature rows with suit recommendations

```typescript
import { SUIT_LABELS } from '@/lib/suit'

export interface SidebarRow {
  date: string
  tempC: number | null
  suit: {
    type: string
    notes?: string
  } | null
  kind?: 'historical' | 'selected' | 'forecast'
}

export interface SidebarTableProps {
  location: {
    lat: number
    lon: number
    display?: string
  }
  rows: SidebarRow[]
  stats: {
    mean: number
    min: number
    max: number
    p10: number
    p90: number
  } | null
  onClose: () => void
}

export function SidebarTable({
  location,
  rows,
  stats,
  onClose,
}: SidebarTableProps) {
  return (
    <div className="w-full md:w-96 h-full bg-white shadow-xl overflow-y-auto">
      {/* Header */}
      <div className="sticky top-0 bg-slate-900 text-white p-4 z-10">
        <div className="flex items-start justify-between">
          <div className="flex-1">
            <h2 className="text-lg font-semibold mb-1">
              {location.display || 'Selected Location'}
            </h2>
            <p className="text-sm text-slate-300">
              {location.lat.toFixed(4)}, {location.lon.toFixed(4)}
            </p>
          </div>
          <button
            onClick={onClose}
            className="text-slate-300 hover:text-white transition-colors"
            aria-label="Close sidebar"
          >
            <svg
              className="w-6 h-6"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                strokeWidth={2}
                d="M6 18L18 6M6 6l12 12"
              />
            </svg>
          </button>
        </div>

        {/* Statistics */}
        {stats && (
          <div className="mt-4 grid grid-cols-3 gap-2 text-xs">
            <div>
              <div className="text-slate-400">Mean</div>
              <div className="font-semibold">{stats.mean.toFixed(1)}°C</div>
            </div>
            <div>
              <div className="text-slate-400">Range</div>
              <div className="font-semibold">
                {stats.min.toFixed(1)}-{stats.max.toFixed(1)}°C
              </div>
            </div>
            <div>
              <div className="text-slate-400">P10-P90</div>
              <div className="font-semibold">
                {stats.p10.toFixed(1)}-{stats.p90.toFixed(1)}°C
              </div>
            </div>
          </div>
        )}
      </div>

      {/* Table */}
      <div className="p-4">
        <table className="w-full text-sm">
          <thead>
            <tr className="border-b border-slate-200">
              <th className="text-left py-2 font-semibold text-slate-700">
                Date
              </th>
              <th className="text-right py-2 font-semibold text-slate-700">
                Temp
              </th>
              <th className="text-right py-2 font-semibold text-slate-700">
                Suit
              </th>
            </tr>
          </thead>
          <tbody>
            {rows.map((row, i) => {
              const isSelected = row.kind === 'selected'
              const isForecast = row.kind === 'forecast'

              return (
                <tr
                  key={i}
                  className={`border-b border-slate-100 ${
                    isSelected ? 'bg-cyan-50' : ''
                  }`}
                >
                  <td className="py-2 text-slate-700">
                    {row.date}
                    {isForecast && (
                      <span className="ml-1 text-xs text-slate-500">
                        (forecast)
                      </span>
                    )}
                  </td>
                  <td className="py-2 text-right font-mono text-slate-900">
                    {row.tempC !== null ? `${row.tempC.toFixed(1)}°C` : '—'}
                  </td>
                  <td className="py-2 text-right">
                    {row.suit ? (
                      <div className="flex flex-col items-end">
                        <span className="font-medium text-slate-900">
                          {SUIT_LABELS[row.suit.type as keyof typeof SUIT_LABELS]}
                        </span>
                        {row.suit.notes && (
                          <span className="text-xs text-slate-500">
                            {row.suit.notes.split(' - ')[0]}
                          </span>
                        )}
                      </div>
                    ) : (
                      <span className="text-slate-400">—</span>
                    )}
                  </td>
                </tr>
              )
            })}
          </tbody>
        </table>
      </div>
    </div>
  )
}
```

#### 2. Integrate Sidebar into Map Page

**File:** `src/routes/index.tsx`

**Changes:** Add point fetching and sidebar display

```typescript
import { createFileRoute } from '@tanstack/react-router'
import { useState, useCallback, useEffect, useRef } from 'react'
import { SSTMap, MapPoint } from '@/components/SSTMap'
import { Legend } from '@/components/Legend'
import { SidebarTable, SidebarRow } from '@/components/SidebarTable'
import { getTodayISO } from '@/lib/dates'

export const Route = createFileRoute('/')({
  component: MapPage,
})

interface PointData {
  location: {
    lat: number
    lon: number
    display?: string
  }
  rows: SidebarRow[]
  stats: any
}

function MapPage() {
  const [selectedDate] = useState(getTodayISO())
  const [points, setPoints] = useState<MapPoint[]>([])
  const [isLoadingGrid, setIsLoadingGrid] = useState(false)
  const [selectedPoint, setSelectedPoint] = useState<PointData | null>(null)
  const [isLoadingPoint, setIsLoadingPoint] = useState(false)
  const debounceTimer = useRef<NodeJS.Timeout | null>(null)

  // ... existing fetchGridData and handleMapMove code ...

  // Fetch point data when map is clicked
  const handleMapClick = useCallback(
    async (lat: number, lon: number) => {
      setIsLoadingPoint(true)

      const url = `/api/sst/point?lat=${lat}&lon=${lon}&date=${selectedDate}&years=7&forecastDays=7`

      try {
        const response = await fetch(url)
        if (!response.ok) throw new Error('Failed to fetch point data')

        const data = await response.json()
        setSelectedPoint(data)
      } catch (err) {
        console.error('Error fetching point data:', err)
        // Show error toast in future
      } finally {
        setIsLoadingPoint(false)
      }
    },
    [selectedDate],
  )

  return (
    <div className="h-screen w-full flex">
      {/* Map */}
      <div className="flex-1 relative">
        <SSTMap
          points={points}
          selectedDate={selectedDate}
          onMapMove={handleMapMove}
          onMapClick={handleMapClick}
        />
        <Legend />
        {isLoadingGrid && (
          <div className="absolute top-4 right-4 bg-slate-900/80 text-white px-4 py-2 rounded-lg text-sm">
            Loading temperature data...
          </div>
        )}
        {isLoadingPoint && (
          <div className="absolute top-16 right-4 bg-slate-900/80 text-white px-4 py-2 rounded-lg text-sm">
            Loading location data...
          </div>
        )}
      </div>

      {/* Sidebar */}
      {selectedPoint && (
        <SidebarTable
          location={selectedPoint.location}
          rows={selectedPoint.rows}
          stats={selectedPoint.stats}
          onClose={() => setSelectedPoint(null)}
        />
      )}
    </div>
  )
}
```

### Success Criteria:

#### Automated Verification:
- [x] Build succeeds: `pnpm build`
- [x] No TypeScript errors

#### Manual Verification:
- [x] Clicking ocean coordinate shows sidebar
- [x] Sidebar displays 15 rows (7 historical + 1 selected + 7 forecast)
- [x] Each row shows date, temperature, and suit recommendation
- [x] Selected date row is highlighted with background color
- [x] Forecast rows are labeled
- [x] Statistics (mean, range, percentiles) display correctly
- [x] Close button hides sidebar
- [x] Clicking new location updates sidebar data
- [x] Null temperatures show as "—"
- [x] Loading indicator appears during fetch

---

## Phase 7: Search & Navigation - Geocoding and URL State

### Overview

Add location search functionality and URL state management for shareable links.

### Changes Required:

#### 1. Create Search Component

**File:** `src/components/SearchBar.tsx` (new file)

**Purpose:** Location search with autocomplete results

```typescript
import { useState, useCallback } from 'react'

interface SearchResult {
  lat: number
  lon: number
  display: string
}

export interface SearchBarProps {
  onSelectLocation: (lat: number, lon: number, display: string) => void
}

export function SearchBar({ onSelectLocation }: SearchBarProps) {
  const [query, setQuery] = useState('')
  const [results, setResults] = useState<SearchResult[]>([])
  const [isSearching, setIsSearching] = useState(false)
  const [showResults, setShowResults] = useState(false)

  const handleSearch = useCallback(async (q: string) => {
    if (!q.trim()) {
      setResults([])
      return
    }

    setIsSearching(true)

    try {
      const response = await fetch(`/api/geocode?q=${encodeURIComponent(q)}`)
      if (!response.ok) throw new Error('Search failed')

      const data = await response.json()
      setResults(data.locations || [])
      setShowResults(true)
    } catch (err) {
      console.error('Search error:', err)
      setResults([])
    } finally {
      setIsSearching(false)
    }
  }, [])

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault()
    handleSearch(query)
  }

  return (
    <div className="relative">
      <form onSubmit={handleSubmit} className="flex gap-2">
        <input
          type="text"
          value={query}
          onChange={(e) => setQuery(e.target.value)}
          onFocus={() => results.length > 0 && setShowResults(true)}
          placeholder="Search for a location..."
          className="flex-1 px-4 py-2 rounded-lg border border-slate-300 focus:outline-none focus:ring-2 focus:ring-cyan-500"
        />
        <button
          type="submit"
          disabled={isSearching || !query.trim()}
          className="px-4 py-2 bg-cyan-600 text-white rounded-lg hover:bg-cyan-700 disabled:opacity-50 disabled:cursor-not-allowed transition-colors"
        >
          {isSearching ? 'Searching...' : 'Search'}
        </button>
      </form>

      {/* Results dropdown */}
      {showResults && results.length > 0 && (
        <div className="absolute top-full mt-2 w-full bg-white rounded-lg shadow-lg border border-slate-200 z-50 max-h-64 overflow-y-auto">
          {results.map((result, i) => (
            <button
              key={i}
              onClick={() => {
                onSelectLocation(result.lat, result.lon, result.display)
                setShowResults(false)
                setQuery('')
              }}
              className="w-full px-4 py-2 text-left hover:bg-slate-50 transition-colors border-b border-slate-100 last:border-b-0"
            >
              <div className="text-sm text-slate-900">{result.display}</div>
              <div className="text-xs text-slate-500">
                {result.lat.toFixed(4)}, {result.lon.toFixed(4)}
              </div>
            </button>
          ))}
        </div>
      )}
    </div>
  )
}
```

#### 2. Add URL State Management

**File:** `src/routes/index.tsx`

**Changes:** Read/write URL parameters for lat, lon, date

```typescript
import { createFileRoute, useNavigate, useSearch } from '@tanstack/react-router'
import { useState, useCallback, useEffect, useRef } from 'react'
import { SSTMap, MapPoint } from '@/components/SSTMap'
import { Legend } from '@/components/Legend'
import { SidebarTable, SidebarRow } from '@/components/SidebarTable'
import { SearchBar } from '@/components/SearchBar'
import { getTodayISO } from '@/lib/dates'
import { z } from 'zod'

// URL search params schema
const searchSchema = z.object({
  lat: z.number().optional(),
  lon: z.number().optional(),
  date: z.string().optional(),
})

export const Route = createFileRoute('/')({
  component: MapPage,
  validateSearch: searchSchema,
})

interface PointData {
  location: {
    lat: number
    lon: number
    display?: string
  }
  rows: SidebarRow[]
  stats: any
}

function MapPage() {
  const navigate = useNavigate()
  const searchParams = useSearch({ from: '/' })

  const [selectedDate] = useState(searchParams.date || getTodayISO())
  const [points, setPoints] = useState<MapPoint[]>([])
  const [isLoadingGrid, setIsLoadingGrid] = useState(false)
  const [selectedPoint, setSelectedPoint] = useState<PointData | null>(null)
  const [isLoadingPoint, setIsLoadingPoint] = useState(false)
  const [mapCenter, setMapCenter] = useState<[number, number] | undefined>(
    searchParams.lat && searchParams.lon
      ? [searchParams.lon, searchParams.lat]
      : undefined,
  )
  const debounceTimer = useRef<NodeJS.Timeout | null>(null)

  // Load point from URL on mount
  useEffect(() => {
    if (searchParams.lat && searchParams.lon) {
      handleMapClick(searchParams.lat, searchParams.lon)
    }
  }, []) // Only run once on mount

  // ... existing fetchGridData and handleMapMove code ...

  const handleMapClick = useCallback(
    async (lat: number, lon: number) => {
      setIsLoadingPoint(true)

      // Update URL
      navigate({
        search: {
          lat,
          lon,
          date: selectedDate,
        },
      })

      const url = `/api/sst/point?lat=${lat}&lon=${lon}&date=${selectedDate}&years=7&forecastDays=7`

      try {
        const response = await fetch(url)
        if (!response.ok) throw new Error('Failed to fetch point data')

        const data = await response.json()
        setSelectedPoint(data)
      } catch (err) {
        console.error('Error fetching point data:', err)
      } finally {
        setIsLoadingPoint(false)
      }
    },
    [selectedDate, navigate],
  )

  const handleSearchSelect = useCallback(
    (lat: number, lon: number, display: string) => {
      // Pan map to location
      setMapCenter([lon, lat])

      // Fetch point data
      handleMapClick(lat, lon)
    },
    [handleMapClick],
  )

  return (
    <div className="h-screen w-full flex flex-col">
      {/* Search bar */}
      <div className="bg-white shadow-md p-4 z-20">
        <div className="max-w-2xl mx-auto">
          <SearchBar onSelectLocation={handleSearchSelect} />
        </div>
      </div>

      {/* Map and sidebar */}
      <div className="flex-1 flex overflow-hidden">
        {/* Map */}
        <div className="flex-1 relative">
          <SSTMap
            points={points}
            selectedDate={selectedDate}
            onMapMove={handleMapMove}
            onMapClick={handleMapClick}
            initialCenter={mapCenter}
          />
          <Legend />
          {isLoadingGrid && (
            <div className="absolute top-4 right-4 bg-slate-900/80 text-white px-4 py-2 rounded-lg text-sm">
              Loading temperature data...
            </div>
          )}
          {isLoadingPoint && (
            <div className="absolute top-16 right-4 bg-slate-900/80 text-white px-4 py-2 rounded-lg text-sm">
              Loading location data...
            </div>
          )}
        </div>

        {/* Sidebar */}
        {selectedPoint && (
          <SidebarTable
            location={selectedPoint.location}
            rows={selectedPoint.rows}
            stats={selectedPoint.stats}
            onClose={() => {
              setSelectedPoint(null)
              // Clear URL params
              navigate({ search: {} })
            }}
          />
        )}
      </div>
    </div>
  )
}
```

### Success Criteria:

#### Automated Verification:
- [ ] Build succeeds: `pnpm build`
- [ ] No TypeScript errors

#### Manual Verification:
- [ ] Search bar appears at top of page
- [ ] Typing "Bergen" and clicking search shows results
- [ ] Clicking result pans map to location and opens sidebar
- [ ] URL updates with `?lat=60.39&lon=5.32&date=2025-11-10` when location selected
- [ ] Pasting URL with parameters loads correct location on page load
- [ ] Closing sidebar clears URL parameters
- [ ] Search results show display name and coordinates

---

## Phase 8: Polish & Responsive Design

### Overview

Add final polish including mobile responsiveness, loading skeletons, error states, and accessibility improvements.

### Changes Required:

#### 1. Make Sidebar Responsive

**File:** `src/components/SidebarTable.tsx`

**Changes:** Add mobile-friendly layout (slide-up drawer on mobile)

```typescript
// ... existing imports ...

export function SidebarTable({
  location,
  rows,
  stats,
  onClose,
}: SidebarTableProps) {
  return (
    <>
      {/* Desktop sidebar */}
      <div className="hidden md:block w-96 h-full bg-white shadow-xl overflow-y-auto">
        {/* ... existing desktop content ... */}
      </div>

      {/* Mobile drawer */}
      <div className="md:hidden fixed inset-x-0 bottom-0 bg-white shadow-xl rounded-t-2xl max-h-[70vh] overflow-y-auto z-30">
        {/* ... same content as desktop ... */}
      </div>

      {/* Mobile backdrop */}
      <div
        className="md:hidden fixed inset-0 bg-black/50 z-20"
        onClick={onClose}
      />
    </>
  )
}
```

#### 2. Add Loading Skeleton

**File:** `src/components/LoadingSkeleton.tsx` (new file)

**Purpose:** Skeleton UI for sidebar loading state

```typescript
export function LoadingSkeleton() {
  return (
    <div className="w-full md:w-96 h-full bg-white shadow-xl p-4 animate-pulse">
      <div className="h-8 bg-slate-200 rounded mb-4" />
      <div className="h-4 bg-slate-200 rounded mb-2" />
      <div className="h-4 bg-slate-200 rounded mb-6 w-2/3" />

      <div className="space-y-2">
        {Array.from({ length: 10 }).map((_, i) => (
          <div key={i} className="h-12 bg-slate-100 rounded" />
        ))}
      </div>
    </div>
  )
}
```

#### 3. Add Error State Component

**File:** `src/components/ErrorState.tsx` (new file)

**Purpose:** User-friendly error display

```typescript
export interface ErrorStateProps {
  title: string
  message: string
  onRetry?: () => void
}

export function ErrorState({ title, message, onRetry }: ErrorStateProps) {
  return (
    <div className="flex flex-col items-center justify-center p-8 text-center">
      <div className="w-16 h-16 rounded-full bg-red-100 flex items-center justify-center mb-4">
        <svg
          className="w-8 h-8 text-red-600"
          fill="none"
          stroke="currentColor"
          viewBox="0 0 24 24"
        >
          <path
            strokeLinecap="round"
            strokeLinejoin="round"
            strokeWidth={2}
            d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"
          />
        </svg>
      </div>
      <h3 className="text-lg font-semibold text-slate-900 mb-2">{title}</h3>
      <p className="text-sm text-slate-600 mb-4">{message}</p>
      {onRetry && (
        <button
          onClick={onRetry}
          className="px-4 py-2 bg-cyan-600 text-white rounded-lg hover:bg-cyan-700 transition-colors"
        >
          Try Again
        </button>
      )}
    </div>
  )
}
```

#### 4. Integrate Loading and Error States

**File:** `src/routes/index.tsx`

**Changes:** Add loading skeleton and error handling

```typescript
// ... existing imports ...
import { LoadingSkeleton } from '@/components/LoadingSkeleton'
import { ErrorState } from '@/components/ErrorState'

// ... existing component code ...

function MapPage() {
  // ... existing state ...
  const [pointError, setPointError] = useState<string | null>(null)

  const handleMapClick = useCallback(
    async (lat: number, lon: number) => {
      setIsLoadingPoint(true)
      setPointError(null)

      navigate({
        search: {
          lat,
          lon,
          date: selectedDate,
        },
      })

      const url = `/api/sst/point?lat=${lat}&lon=${lon}&date=${selectedDate}&years=7&forecastDays=7`

      try {
        const response = await fetch(url)
        if (!response.ok) {
          throw new Error(`Server error: ${response.status}`)
        }

        const data = await response.json()
        setSelectedPoint(data)
      } catch (err) {
        console.error('Error fetching point data:', err)
        setPointError('Failed to load temperature data. Please try again.')
      } finally {
        setIsLoadingPoint(false)
      }
    },
    [selectedDate, navigate],
  )

  return (
    <div className="h-screen w-full flex flex-col">
      {/* ... search bar ... */}

      <div className="flex-1 flex overflow-hidden">
        {/* Map */}
        <div className="flex-1 relative">
          {/* ... existing map code ... */}
        </div>

        {/* Sidebar with loading and error states */}
        {isLoadingPoint && <LoadingSkeleton />}
        {pointError && !isLoadingPoint && (
          <div className="w-full md:w-96 bg-white shadow-xl">
            <ErrorState
              title="Failed to Load Data"
              message={pointError}
              onRetry={() => {
                if (searchParams.lat && searchParams.lon) {
                  handleMapClick(searchParams.lat, searchParams.lon)
                }
              }}
            />
          </div>
        )}
        {selectedPoint && !isLoadingPoint && !pointError && (
          <SidebarTable
            location={selectedPoint.location}
            rows={selectedPoint.rows}
            stats={selectedPoint.stats}
            onClose={() => {
              setSelectedPoint(null)
              navigate({ search: {} })
            }}
          />
        )}
      </div>
    </div>
  )
}
```

#### 5. Add Keyboard Accessibility

**File:** `src/components/SearchBar.tsx`

**Changes:** Add keyboard navigation for search results

```typescript
// ... in SearchBar component ...

const [selectedIndex, setSelectedIndex] = useState(0)

const handleKeyDown = (e: React.KeyboardEvent) => {
  if (!showResults || results.length === 0) return

  switch (e.key) {
    case 'ArrowDown':
      e.preventDefault()
      setSelectedIndex((i) => Math.min(i + 1, results.length - 1))
      break
    case 'ArrowUp':
      e.preventDefault()
      setSelectedIndex((i) => Math.max(i - 1, 0))
      break
    case 'Enter':
      e.preventDefault()
      if (results[selectedIndex]) {
        const result = results[selectedIndex]
        onSelectLocation(result.lat, result.lon, result.display)
        setShowResults(false)
        setQuery('')
      }
      break
    case 'Escape':
      setShowResults(false)
      break
  }
}

// Add to input:
<input
  // ... existing props ...
  onKeyDown={handleKeyDown}
  aria-label="Search for location"
  aria-autocomplete="list"
  aria-controls="search-results"
  role="combobox"
  aria-expanded={showResults}
/>

// Update results container:
<div
  id="search-results"
  role="listbox"
  // ... rest of props ...
>
  {results.map((result, i) => (
    <button
      key={i}
      role="option"
      aria-selected={i === selectedIndex}
      className={`... ${i === selectedIndex ? 'bg-cyan-50' : ''}`}
      // ... rest of props ...
    />
  ))}
</div>
```

#### 6. Update Header for Branding

**File:** `src/components/Header.tsx`

**Changes:** Update to match app purpose

```typescript
import { Link } from '@tanstack/react-router'

export default function Header() {
  return (
    <header className="bg-cyan-600 text-white shadow-md">
      <div className="container mx-auto px-4 py-3 flex items-center justify-between">
        <Link to="/" className="flex items-center gap-2">
          <svg
            className="w-8 h-8"
            fill="none"
            stroke="currentColor"
            viewBox="0 0 24 24"
          >
            <path
              strokeLinecap="round"
              strokeLinejoin="round"
              strokeWidth={2}
              d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"
            />
          </svg>
          <h1 className="text-xl font-bold">Dive Suit Recommender</h1>
        </Link>
        <p className="hidden md:block text-sm text-cyan-100">
          Find the right wetsuit for any dive location
        </p>
      </div>
    </header>
  )
}
```

### Success Criteria:

#### Automated Verification:
- [x] Build succeeds: `pnpm build`
- [x] No TypeScript errors
- [x] No accessibility linting errors

#### Manual Verification:
- [x] Sidebar slides up from bottom on mobile (<768px)
- [x] Sidebar is fixed-width panel on desktop (≥768px)
- [x] Loading skeleton appears while fetching point data
- [x] Error state shows with retry button when API fails
- [x] Keyboard arrows navigate search results
- [x] Enter key selects highlighted search result
- [x] Escape key closes search results
- [x] Focus indicators visible on all interactive elements
- [x] Screen reader announces search results (test with VoiceOver/NVDA)
- [ ] Header displays app name and icon (not implemented - using simple search bar instead)
- [x] All touch targets are ≥44px for mobile usability

---

## Performance Considerations

1. **Caching Strategy:**
   - Grid data: 15 min TTL (frequent updates, large payloads)
   - Historical data: 24 hr TTL (unchanging)
   - Forecast data: 30 min TTL (semi-frequent updates)
   - Geocoding: 24 hr TTL (unchanging)

2. **Request Optimization:**
   - Debounce map movement (400ms)
   - Adaptive grid resolution based on zoom
   - Limit grid size to 1000 points maximum
   - Use multi-coordinate API for grid (batch requests)

3. **Rendering Performance:**
   - Heatmap layer leverages GPU acceleration via MapLibre
   - GeoJSON source updates only on data change
   - Sidebar virtualization not needed (max 15 rows)

4. **Future Optimizations:**
   - Add service worker for offline basemap tiles
   - Implement request deduplication for concurrent calls
   - Add Redis/Memcached for multi-instance deployments
   - Compress API responses with gzip/brotli

---

## Migration Notes

N/A - This is a greenfield implementation with no existing data to migrate.

---

## References

- Original ticket: `.claude/tickets/0001-mvp.md`
- TanStack Start docs: https://tanstack.com/start
- MapLibre GL JS docs: https://maplibre.org/maplibre-gl-js/docs/
- Open-Meteo Marine API: https://open-meteo.com/en/docs/marine-weather-api
- Nominatim API: https://nominatim.org/release-docs/develop/api/Overview/
- shadcn/ui components: https://ui.shadcn.com/
